/* global APP_TITLE, SPEECH_API_KEY, COMMIT_HASH */
import AudioDataEngine from './AudioDataEngine';
import encodeWav from './encoders/wav';
import encodeMp3 from './encoders/mp3';
import eventEmitter from 'event-emitter';
import allOff from 'event-emitter/all-off';
import { requirements } from '../util/loadRequirements';
import normalizeSpaces from '../util/normalizeSpaces';
import getVoices, { getSpeechVoice } from '../engine/speech-voices';
import { logExportEvent } from '../util/analytics';

import logoIcon from '../images/two-tone-logo-32.png';

const RENDER_PROGRESS_RATIO = 0.4;

const encoders = {
	wav: encodeWav,
	mp3: encodeMp3
};

const fetchIcon = () =>
	fetch(logoIcon)
		.then(response => response.arrayBuffer());

/*
MS Edge doesn't support options object in constructor
*/
function createOfflineContext(options) {
	const { OfflineAudioContext } = requirements.AudioContext;
	try {
		const context = new OfflineAudioContext(options);
		return context;
	} catch (e) { console.log('Offline rendering error:' + e)}

	const {
		numberOfChannels,
		length,
		sampleRate
	} = options;
	return new OfflineAudioContext(numberOfChannels, length, sampleRate);
}

/*
May want to add opus
- https://github.com/psirenny/opus-encode
- https://github.com/Rillke/opusenc.js
*/
export default function ExportEngine(state, options = {}) {
	const sampleRate = options.sampleRate || 44100;
	const format = (options.format || 'mp3').toLowerCase();
	const bitRate = options.bitRate || 128; // in kb, only for mp3

	/*
	todo:
	- abort if no data, tracks or duration
	*/

	let engine = null;
	let nextTaskId = 1;
	let currentTaskId = 0;
	let progress = 0;
	let abortController = null;

	function log(action) {
		logExportEvent({
			sampleRate,
			exportFormat: format,
			bitRate,
			duration: Math.round(state.duration * 1000)
		}, action);
	}

	this.start = async () => {
		if (engine) {
			throw new Error('Already rendering audio for export');
		}

		const taskId = nextTaskId++;
		currentTaskId = taskId;
		progress = 0;

		const duration = state.duration;

		const context = createOfflineContext({
			numberOfChannels: 2,
			length: sampleRate * duration,
			sampleRate
		});
		// const context = new OfflineAudioContext(2, sampleRate * duration, sampleRate);
		engine = new AudioDataEngine(context);
		engine.data = state.data;
		engine.tracks = state.tracks || [];
		engine.rowDuration = state.rowDuration;
		engine.speechTitleEnabled = state.speechTitleEnabled;
		engine.speechTitle = normalizeSpaces(state.speechTitleEnabled && state.speechTitle);
		if (SPEECH_API_KEY && engine.speechTitle) {
			await getVoices();
			engine.speechVoiceId = getSpeechVoice(state);
		}
		engine.update();

		engine.on('timeupdate', () => {
			progress = Math.max(progress, RENDER_PROGRESS_RATIO * engine.currentTime / duration);
			this.emit('progress');
		});

		log('save');

		await engine.play();
		// console.log('starting rendering', context.currentTime, context);
		const savedBuffer = await context.startRendering();
		// console.log('done rendering export', {savedBuffer});

		if (!engine) {
			// aborted
			return null;
		}

		engine.destroy();
		engine = null;

		if (currentTaskId !== taskId) {
			// aborted and started new task
			return null;
		}

		abortController = window.AbortController && new AbortController();
		const abortSignal = abortController && abortController.signal;

		const comments = (state.tracks || []).map(track => {
			const {intensityField} = track;
			const field = state.data.fields[intensityField];
			return field && '- ' + field.name || '';
		});
		comments.push('', `Generated by ${APP_TITLE} (build ${COMMIT_HASH})`);
		const comment = comments.join('\n');

		const meta = {
			TIT2: state.dataSource.metadata.title,
			TENC: APP_TITLE,
			ISFT: APP_TITLE,
			COMM: {
				description: 'Comment',
				text: comment
			},
			APIC: {
				type: 3,
				data: await fetchIcon(),
				description: APP_TITLE,
				useUnicodeEncoding: false
			}
		};

		const encode = encoders[format];
		const encodedBlob = await encode(savedBuffer, meta, bitRate, p => {
			progress = Math.max(progress, RENDER_PROGRESS_RATIO + (1 - RENDER_PROGRESS_RATIO) * p);
			this.emit('progress');
		}, abortSignal);

		if (currentTaskId !== taskId) {
			// aborted and started new task
			return null;
		}
		abortController = null;

		log('complete');

		currentTaskId = 0;
		progress = 1;
		this.emit('finish', encodedBlob);
		return encodedBlob;
	};

	this.abort = () => {
		if (engine) {
			engine.destroy();
		}
		engine = null;

		if (abortController) {
			abortController.abort();
		}
		abortController = null;

		log('abort');

		const taskId = currentTaskId;
		currentTaskId = 0;
		if (taskId) {
			this.emit('abort');
		}
	};

	this.destroy = () => {
		this.abort();
		allOff(this);
	};

	eventEmitter(this);

	Object.defineProperties(this, {
		processing: {
			get: () => !!engine
		},
		progress: {
			get: () => progress
		}
	});
}
