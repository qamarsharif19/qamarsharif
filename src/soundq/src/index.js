import eventEmitter from 'event-emitter';
import allOff from 'event-emitter/all-off';
import num from './util/num';
import computeOptions from './util/computeOptions';

const MIN_LOOK_AHEAD = 0.05; // seconds
const OFFLINE_LOOK_AHEAD = 20;
const MAX_SCHEDULED_SOUNDS = 100;
const OFFLINE_MAX_SCHEDULED_SOUNDS = 500;

let mainContext = null;
const mainContextUsers = new Set();

function getMainContext(instance) {
	if (!mainContext) {
		mainContext = new AudioContext();
	}
	mainContextUsers.add(instance);
	return mainContext;
}

function releaseMainContext(instance) {
	mainContextUsers.delete(instance);
	if (!mainContextUsers.size && mainContext) {
		if (mainContext.close && mainContext.state !== 'closed') {
			mainContext.close();
		}
		mainContext = null;
	}
}

// sort by start time
function sortUnscheduled(a, b) {
	// deprioritize events that don't have an end time yet
	if (a.stopTime === Infinity && b.stopTime !== Infinity) {
		return 1;
	}
	if (b.stopTime === Infinity && a.stopTime !== Infinity) {
		return -1;
	}

	const startDiff = a.startTime - b.startTime;
	if (startDiff) {
		return startDiff;
	}

	const stopDiff = a.stopTime - b.stopTime;
	if (stopDiff) {
		return stopDiff;
	}

	const releaseDiff = a.releaseTime - b.releaseTime;
	if (releaseDiff) {
		return releaseDiff;
	}

	return a.id - b.id;
}

function sortPlayed(a, b) {
	const stopDiff = a.stopTime - b.stopTime;
	if (stopDiff) {
		return stopDiff;
	}

	const releaseDiff = a.releaseTime - b.releaseTime;
	if (releaseDiff) {
		return releaseDiff;
	}

	const startDiff = a.startTime - b.startTime;
	if (startDiff) {
		return startDiff;
	}

	return a.id - b.id;
}

let nextSoundEventId = 1;
let nextShotId = 1;

function SoundQ(options = {}) {
	const context = options.context || getMainContext(this);

	const cacheExpiration = Math.max(0, num(options.cacheExpiration, 10)) * 1000; // seconds -> milliseconds
	const isOffline = !!context.startRendering;
	const contextFinalTime = isOffline ? context.length / context.sampleRate : Infinity;

	const minLookAhead = isOffline ?
		Math.min(OFFLINE_LOOK_AHEAD, contextFinalTime) :
		MIN_LOOK_AHEAD;

	const maxScheduledSounds = isOffline ?
		OFFLINE_MAX_SCHEDULED_SOUNDS :
		MAX_SCHEDULED_SOUNDS;

	// queues, maps and sets for various pools and events
	const liveShotsByPublic = new Map(); // by object
	const liveShots = new Map(); // by id
	const sourcePools = new Map();
	const patchPools = new Map();
	const soundEvents = new Map();
	const unscheduledQueue = [];
	const playedSounds = [];

	let scheduling = false;
	let earliestStopTime = Infinity;
	let cleanUpTimeout = 0;
	let destroyed = false;
	let scheduledSuspend = Infinity;

	function cleanUp() {
		clearTimeout(cleanUpTimeout);
		cleanUpTimeout = 0;

		const now = Date.now();
		let maxAge = -1;

		function cleanPool(pool, key, map) {
			while (pool.length) {
				const obj = pool[0];
				const age = now - obj.lastUsed;
				if (age < cacheExpiration && !destroyed) {
					maxAge = Math.max(maxAge, age);
					return;
				}

				if (obj.destroy) {
					obj.destroy();
				}
				pool.shift();
			}

			// Delete empty pool from map
			map.delete(key);
		}

		patchPools.forEach(cleanPool);
		sourcePools.forEach(cleanPool);

		if (maxAge >= 0) {
			cleanUpTimeout = setTimeout(cleanUp, Math.max(20, cacheExpiration - maxAge));
		}
	}

	function scheduleCleanUp() {
		if (!cleanUpTimeout) {
			cleanUpTimeout = setTimeout(cleanUp, cacheExpiration);
		}
	}

	function updatePatch(source) {
		const {
			patch,
			patchOptions,
			startTime,
			releaseTime,
			stopTime
		} = source;
		if (patch && patch.start && stopTime > context.currentTime) {
			// compute patch options if there are any functions
			patch.start(startTime, releaseTime, stopTime, computeOptions(
				patchOptions,
				{ startTime, releaseTime, stopTime }
			));
		}
	}

	function startSoundEvent(sound) {
		const { source, shot } = sound;
		if (source.startEvent) {
			sound = Object.assign(sound, source.startEvent(sound));
			sound.scheduled = true;
		}

		if (shot) {
			if (shot.patchDef && !shot.patch) {
				shot.patch = getPatch(shot.patchDef);
			}
			updatePatch(shot);
		}

		// todo: use optional output destination
		if (sound.output && sound.output.connect) {
			const dest = shot && shot.patch && shot.patch.input || context.destination;
			sound.output.connect(dest);

			if (shot && shot.patch && shot.patch.output) {
				shot.patch.output.connect(context.destination);
			}
		}

		const needsSorting = playedSounds.length && sound.startTime <= playedSounds[0].startTime;
		playedSounds.push(sound);
		if (needsSorting) {
			playedSounds.sort(sortPlayed);
		}
	}

	/*
	Schedule individual sound events generated by sources
	*/
	function scheduleSounds() {
		if (scheduling) {
			return;
		}

		scheduling = true;

		const urgentTime = context.currentTime + minLookAhead;
		liveShots.forEach(shot => {
			const { source } = shot;
			if (source.request && shot.stopTime > context.currentTime) {
				let event = null;
				do {
					event = source.request(urgentTime);
					if (event && typeof event === 'object') {
						source.controller.submit(event);
					}
				} while (event);
			}
		});

		let untilTime = earliestStopTime + minLookAhead;
		const liveShotsCopy = new Set(liveShots.values());
		while (liveShotsCopy.size) {
			for (const shot of liveShotsCopy) {
				const { source } = shot;

				let event = null;

				// if this is an offline context, don't schedule any sounds that don't have an end time
				if (source.request && shot.stopTime > context.currentTime && (!isOffline || shot.stopTime < Infinity)) {
					untilTime = Math.min(untilTime, earliestStopTime + minLookAhead);
					event = source.request(untilTime);
					if (event && typeof event === 'object') {
						source.controller.submit(event);
						earliestStopTime = Math.min(earliestStopTime, event.stopTime);
					}
				}

				if (!event) {
					liveShotsCopy.delete(shot);
				}
			}
		}
		/*
		todo: loop through any started sound events
		- fade out anything that's been playing a long time if we're over the limit
		- cancel anything that's too far out
		- this queue is sorted by stop time
		*/
		// for (let i = 0, n = playedSounds.length; i < n; i++) {
		// 	const sound = playedSounds[i];
		// }

		/*
		todo: loop through submitted sound events
		- cancel anything that's too far out
		- this queue is sorted by start time
		  - so we can end early
		  - efficiently store earliest stopTime
		  - probably faster to use binary insert
		*/
		while (unscheduledQueue.length && (
			playedSounds.length < maxScheduledSounds ||
				scheduledSuspend < Infinity ||
				isOffline && unscheduledQueue[0].startTime <= context.currentTime + minLookAhead
		)) {
			const sound = unscheduledQueue.shift();

			/*
			todo:
			note that the time between NOW and startTime should be less than min latency...
			Use the time between the FIRST stopTime of scheduled sound and startTime.
			*/
			if (sound.stopTime > Math.max(context.currentTime, sound.startTime)) {
				startSoundEvent(sound);
			} else {
				// we missed one!
				console.log('Missed sound!', sound, context.currentTime);
				revoke(sound.id);
			}
		}

		if (isOffline && context.suspend && (unscheduledQueue.length || playedSounds.length * 2 >= MAX_SCHEDULED_SOUNDS) && scheduledSuspend === Infinity && context.state === 'running') {
			const suspendTime = Math.max(
				context.currentTime + 250 / context.sampleRate,
				Math.min(unscheduledQueue[0] && unscheduledQueue[0].startTime - 0.05 || 0, earliestStopTime)
			);
			if (suspendTime < contextFinalTime) {
				scheduledSuspend = suspendTime;
				context.suspend(suspendTime).then(() => {
					scheduledSuspend = Infinity;
					context.resume();
					// try {
					// 	context.resume();
					// } catch (e) {
					// 	console.warn('failed to resume', e);
					// }
					scheduleSounds();
				});
			}
		}

		scheduling = false;
	}

	function calculateEarliestStopTime() {
		earliestStopTime = Infinity;
		for (let i = 0; i < playedSounds.length; i++) {
			const {startTime, stopTime} = playedSounds[i];
			if (stopTime > context.currentTime && stopTime > startTime) {
				earliestStopTime = stopTime;
				break;
			}
		}
	}

	function revoke(eventId) {
		const sound = soundEvents.get(eventId);
		if (sound) {
			const { source, shot } = sound;
			sound.stopped = true;

			if (sound.scheduled) {
				const index = playedSounds.findIndex(s => s.id === eventId);
				if (index >= 0) {
					playedSounds.splice(index, 1);
				}

				if (source.finishEvent) {
					source.finishEvent(sound);
				}

				if (sound.output) {
					sound.output.disconnect();
				}
			}

			soundEvents.delete(eventId);
			shot.events.delete(sound);
			// todo: fire sound stop event

			if (shot && !shot.events.size && (shot.stopTime <= context.currentTime || shot.source.done && shot.source.done())) {
				// todo: fire shot stop event
				liveShots.delete(shot.id);

				const shotList = liveShotsByPublic.get(shot.publicShot);
				shotList.delete(shot.id);

				if (source.finish) {
					source.finish();
				}

				freeSource(source);

				if (shot.patch) {
					freePatch(shot.patch);
					shot.patch = null;
				}
			}

			calculateEarliestStopTime();

			if (sound.startTime < context.currentTime) {
				// only schedule further if this sound has actually played
				scheduleSounds();
			}
		}
	}

	function stop(id, stopTime) {
		const sound = soundEvents.get(id);
		if (sound && sound.stopTime !== stopTime) {
			sound.stopTime = stopTime;
			if (sound.scheduled) {
				if (sound.source.stopEvent) {
					sound.source.stopEvent(sound);
				}

				// re-sort played sounds, update earliest stopTime if needed
				playedSounds.sort(sortPlayed);

				calculateEarliestStopTime();

			}
			scheduleSounds();
		}
	}

	function makeShotSource(definition) {
		let source = null;

		const controller = {
			context,

			// todo: move functions up to top level if possible
			submit(details) {
				const id = details.id || nextSoundEventId++;
				const soundEvent = soundEvents.get(id) || {
					id,
					source,
					shot: source.shot,
					output: null,
					stopped: false,
					scheduled: false,

					// todo: we probably don't need release on individual events
					// source can handle it internally
					releaseTime: Infinity,
					stopTime: Infinity
				};
				Object.assign(soundEvent, details);
				soundEvent.releaseTime = Math.min(soundEvent.releaseTime, soundEvent.stopTime);

				if (soundEvents.has(id) && soundEvent.scheduled) {
					// todo: update this? maybe cannot be changed if already started
				} else {
					const needsSorting = unscheduledQueue.length && soundEvent.startTime <= unscheduledQueue[unscheduledQueue.length - 1].startTime;
					const newSound = !soundEvents.has(id);
					if (newSound) {
						unscheduledQueue.push(soundEvent);
					}
					if (needsSorting) {
						// only sort when we need to
						unscheduledQueue.sort(sortUnscheduled);
					}
					soundEvents.set(id, soundEvent);
					soundEvent.shot.events.add(soundEvent);

					if (soundEvent.stopTime >= context.currentTime) {
						earliestStopTime = Math.min(earliestStopTime, soundEvent.stopTime);
					}
				}

				return id;
			},

			// means we're really, really done with this
			revoke,

			// clean up
			stop,

			get: key => source.props[key],

			// in case source wants to build in a patch
			getPatch,
			freePatch,

			// add get/release source
			getSource,
			freeSource,

			schedule: scheduleSounds
		};

		source = Object.assign(definition(controller), {
			controller,
			definition,
			shot: null,
			props: {},
			lastUsed: Number.MAX_SAFE_INTEGER
		});

		const set = source.set;
		source.set = (key, val) => {
			if (!source.shot || source.shot.props !== source.props) {
				source.props[key] = val;
			}
			if (set) {
				set.call(source, key, val);
			}
		};

		return source;
	}

	function startSourceShot(shot, time, options) {
		// todo: what if we're already active?
		const { source } = shot;
		if (source.start) {
			source.start(time, options);
		}
		// todo: set release, stopTime to Infinity

		scheduleSounds();
	}

	function releaseSourceShot(shot, time) {
		// todo: what if we're already released?
		const { source } = shot;
		shot.releaseTime = time;
		if (source.release) {
			source.release(time);
		} else if (source.stop) {
			source.stop(time);
		}
		updatePatch(shot);
		scheduleSounds();
	}

	function stopSourceShot(shot, time) {
		// todo: what if we're already stopped?
		// todo: release if release time is before this
		const { source } = shot;
		shot.stopTime = time;
		if (source.stop) {
			source.stop(time);
		}
		updatePatch(shot);
		scheduleSounds();
	}

	function getSource(definition) {
		const pool = sourcePools.get(definition);
		if (pool && pool.length) {
			return pool.pop();
		}

		return makeShotSource(definition);
	}

	function freeSource(source) {
		const expired = typeof source.expired === 'function' ?
			source.expired() :
			!!source.expired;
		if (expired) {
			/*
			Some sources cannot be re-used (e.g. AudioScheduledSourceNode),
			so destroy them rather than adding back to the pool.
			*/
			if (source.destroy) {
				source.destroy();
			}
			return;
		}

		let pool = sourcePools.get(source.definition);
		if (!pool) {
			pool = [];
			sourcePools.set(source.definition, pool);
		}

		source.shot = null;
		source.lastUsed = Date.now();

		pool.push(source);
		scheduleCleanUp();
	}

	function getPatch(definition) {
		const pool = patchPools.get(definition);
		if (pool && pool.length) {
			return pool.pop();
		}

		const patch = definition(context);
		patch.definition = definition;
		patch.lastUsed = Number.MAX_SAFE_INTEGER;

		if (patch.input === undefined) {
			patch.input = patch.node;
		}
		if (patch.output === undefined) {
			patch.output = patch.node;
		}

		return patch;
	}

	function freePatch(patch) {
		if (patch.reset) {
			patch.reset();
		}

		/*
		Assume patch will have been disconnected by source.
		We don't want to disconnect every node in the patch,
		since it might have some that are connected elsewhere.
		*/

		if (patch.output) {
			try {
				patch.output.disconnect(context.destination);
			} catch (e) {
				//console.log('debug warning: Patch.output.disconnect not possible')
				}
		}

		const expired = typeof patch.expired === 'function' ?
			patch.expired() :
			!!patch.expired;

		if (expired) {
			if (patch.destroy) {
				patch.destroy();
			}
			return;
		}

		// return it to the pool
		let pool = patchPools.get(patch.definition);
		if (!pool) {
			pool = [];
			patchPools.set(patch.definition, pool);
		}

		// store timestamp for pruning later
		patch.lastUsed = Date.now();
		pool.push(patch);
		scheduleCleanUp();
	}

	this.shot = (sourceFn, patchDef) => {
		// todo: if source is a buffer, create a new source for it
		// todo: if source is an AudioScheduledSourceNode, create new source for it?
		// todo: shuffle around order so code makes sense
		// todo: get destination somewhere. shot options? play options?

		const defaultProps = {};
		const shotList = new Map();

		// todo: emit events
		const publicShot = {
			context,

			/*
			We may decide to merge options and patchOptions somehow
			*/
			start(startTime = context.currentTime, options, patchOptions) {
				if (typeof startTime !== 'number' && startTime !== undefined) {
					patchOptions = options;
					options = startTime;
					startTime = context.currentTime;
				}

				const id = nextShotId++;
				const source = getSource(sourceFn);

				const shotInfo = {
					id,
					publicShot,
					source,
					events: new Set(),
					patchDef,
					startTime,
					releaseTime: Infinity,
					stopTime: Infinity,
					props: {...defaultProps},
					patchOptions
				};

				source.shot = shotInfo;
				source.props = shotInfo.props;

				for (const key in source.props) {
					if (Object.prototype.hasOwnProperty.call(source.props, key)) {
						source.set(key, source.props[key]);
					}
				}

				liveShots.set(id, shotInfo);
				shotList.set(id, shotInfo);
				startSourceShot(shotInfo, startTime, options);
				return id;
			},
			release(releaseTime = context.currentTime, id) {

				// handle missing id for this shot def
				if (id === undefined) {
					shotList.forEach(s => {
						releaseSourceShot(s, releaseTime);
					});
					return publicShot;
				}

				const s = shotList.get(id);
				if (s) {
					releaseSourceShot(s, releaseTime);
				}

				return publicShot;
			},
			stop(stopTime = context.currentTime, id) {

				// handle missing id for this shot def
				if (id === undefined) {
					shotList.forEach(s => {
						if (s.stopTime > stopTime) {
							stopSourceShot(s, stopTime);
						}
					});
					return publicShot;
				}

				const s = shotList.get(id);
				if (s) {
					stopSourceShot(s, stopTime);
				}

				return publicShot;
			},
			set(id, key, value) {
				if (typeof id !== 'number') {
					value = key;
					key = id;
					id = undefined;
				}

				const shotInfo = liveShots.get(id);
				if (id !== undefined && !shotInfo) {
					return publicShot;
				}

				const props = shotInfo ? shotInfo.props : defaultProps;

				if (typeof key === 'string') {
					props[key] = value;
					if (shotInfo && shotInfo.source.set) {
						shotInfo.source.set(key, value);
					}
				} else if (key && typeof key === 'object') {
					Object.assign(props, key);
					if (id) {
						for (const k in key) {
							if (Object.prototype.hasOwnProperty.call(key, k)) {
								publicShot.set(id, k, key[k]);
							}
						}
					}
				}

				if (id === undefined) {
					shotList.forEach(s => {
						publicShot.set(s.id, key, value);
					});
				}

				return publicShot;
			},
			destroy() {
				// todo: remove any event listeners
				shotList.forEach(s => {
					stopSourceShot(s, context.currentTime);
					s.events.forEach(e => revoke(e.id));
				});
				liveShotsByPublic.delete(publicShot);
			}
		};

		liveShotsByPublic.set(publicShot, shotList);

		return publicShot;
	};

	this.stop = time => {
		liveShotsByPublic.forEach((list, publicShot) => publicShot.stop(time));
	};

	this.destroy = () => {
		destroyed = true;

		liveShotsByPublic.forEach((list, publicShot) => publicShot.destroy());
		cleanUp();
		releaseMainContext(this);

		this.emit('destroy');
		allOff(this);
	};

	Object.defineProperties(this, {
		context: {
			value: context
		},
		currentTime: {
			get: () => context.currentTime
		}
	});
}

eventEmitter(SoundQ.prototype);

export default SoundQ;
